syntax = "proto2";
import public "common_client.proto";
import public "pez_base.proto";
import public "common_enum.proto";
import public "pez_desk.proto";

package ddproto;
option optimize_for = LITE_RUNTIME;

////////////////////////////////////////////////////////////////////
// 通信协议

//积分
message pez_user_coin_bean {
    optional uint32 userId = 1; //玩家id
    optional int64 coin = 2; //本场的积分
}

// 开局（接收服务端消息）
message pez_Opening {
    optional ProtoHeader header = 1;
    optional int32 CurrPlayCount = 2; //当前玩到第几局
    optional int32 dice1 = 3; //骰子的数目
    optional int32 dice2 = 4; //骰子的数目
    optional int64 lastScore = 5;
    repeated pez_user_coin_bean userCoinBeans = 6; //玩家的详细信息
}

// 发牌
message pez_DealCards {
    optional ProtoHeader header = 1;
}

// 押注
message pez_Bet {
    optional uint32 userId = 1; // 押注的人
    optional int64 betNum = 2; // 押注的数量
    optional int32 time = 3; // 押注剩余时间
}

message pez_AckBet {
    optional ProtoHeader header = 1;
    optional uint32 userId = 2; // 押注的人
    optional int64 betCount = 3; // 押注的数量
    optional int32 time = 4; // 押注剩余时间
}

message pez_BCOpenPai {
    optional uint32 userId = 1;
    repeated pez_base_PaiInfo handPai = 2;
    optional int32 keyValue = 3;
}

//链接类型
enum PEZ_RECONNECT_TYPE {
    PEZ_NORMAL = 1;
    PEZ_RECONNECT = 2;
}
// 发送游戏信息(广播)
message pez_SendGameInfo {
    optional ProtoHeader header = 1;
    // 1. 首先是牌桌的玩家数据（玩家数据包括其id昵称筹码头像等基本信息，其手牌数据，以及自己打开牌的数据，还有状态是否已经押注了，玩家在整局的总输赢）
    repeated pez_base_PlayerInfo playerInfo = 2;
    // 2. 桌面信息（包括：游戏是否结束，当前哪个玩家未押注，倒计时剩余时间）
    optional pez_base_DeskGameInfo deskGameInfo = 3;
    //
    optional uint32 senderUserId = 4; // 发起请求的人

    optional bool isReconnect = 5; // 1=正常连接（默认） 2=断线重连
}
